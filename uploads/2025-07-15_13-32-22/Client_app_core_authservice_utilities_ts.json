```
typescript
import { Injectable } from '@angular/core';
import { HttpErrorResponse } from '@angular/common/http';

@Injectable({
  providedIn: 'root'
})
export class Utilities {

  public static readonly captionAndMessageSeparator = ":";
  public static readonly noNetworkMessageCaption = "No Network";
  public static readonly noNetworkMessageDetail = "The server cannot be reached";
  public static readonly accessDeniedMessageCaption = "Access Denied!";
  public static readonly accessDeniedMessageDetail = "";

  public static getHttpResponseMessage(data: HttpErrorResponse | any): string[] {
    const responses: string[] = [];

    if (data instanceof HttpErrorResponse) {
      if (this.checkNoNetwork(data)) {
        responses.push(`${this.noNetworkMessageCaption}${this.captionAndMessageSeparator} ${this.noNetworkMessageDetail}`);
      } else {
        try {
          const responseObject = data.error || data;
          if (typeof responseObject === 'object' && responseObject !== null) {
            Object.keys(responseObject).forEach(key => {
              if (key) {
                responses.push(`${key}${this.captionAndMessageSeparator} ${responseObject[key]}`);
              } else if (responseObject[key]) {
                responses.push(responseObject[key].toString());
              }
            });
          }
        } catch (error) {
          // swallow error
        }
      }
      if (!responses.length && data.message) {
        responses.push(`${data.statusText}: ${data.message}`);
      }
    } else {
      responses.push(data.toString());
    }

    if (!responses.length) {
      responses.push(data.toString());
    }

    if (this.checkAccessDenied(data)) {
      responses.splice(0, 0, `${this.accessDeniedMessageCaption}${this.captionAndMessageSeparator} ${this.accessDeniedMessageDetail}`);
    }

    return responses;
  }

  public static findHttpResponseMessage(messageToFind: string, data: HttpErrorResponse | any, seachInCaptionOnly = true, includeCaptionInResult = false): string {
    const searchString = messageToFind.toLowerCase();
    const httpMessages = this.getHttpResponseMessage(data);

    for (const message of httpMessages) {
      const fullMessage = Utilities.splitInTwo(message, this.captionAndMessageSeparator);
      if (fullMessage.firstPart && fullMessage.firstPart.toLowerCase().indexOf(searchString) !== -1) {
        return includeCaptionInResult ? message : fullMessage.secondPart || fullMessage.firstPart;
      }
    }

    if (!seachInCaptionOnly) {
      for (const message of httpMessages) {
        if (message.toLowerCase().indexOf(searchString) !== -1) {
          if (includeCaptionInResult) {
            return message;
          } else {
            const fullMessage = Utilities.splitInTwo(message, this.captionAndMessageSeparator);
            return fullMessage.secondPart || fullMessage.firstPart;
          }
        }
      }
    }

    return null;
  }

  public static checkNoNetwork(response: HttpErrorResponse | any): boolean {
    return response && response.status !== undefined ? response.status === 0 : false;
  }

  public static checkAccessDenied(response: HttpErrorResponse | any): boolean {
    return response && response.status !== undefined ? response.status === 403 : false;
  }

  public static checkNotFound(response: HttpErrorResponse | any): boolean {
    return response && response.status !== undefined ? response.status === 404 : false;
  }

  public static checkIsLocalHost(url: string, base?: string): boolean {
    if (url) {
      const location = new URL(url, base);
      return location.hostname === "localhost" || location.hostname === "127.0.0.1";
    }
    return false;
  }

  public static getQueryParamsFromString(paramString: string): { [key: string]: string } {
    if (!paramString) return null;

    const params: { [key: string]: string } = {};

    paramString.split("&").forEach(param => {
      const keyValue = Utilities.splitInTwo(param, "=");
      params[keyValue.firstPart] = keyValue.secondPart;
    });

    return params;
  }

  public static splitInTwo(text: string, separator: string): { firstPart: string, secondPart: string } {
    const separatorIndex = text.indexOf(separator);

    if (separatorIndex === -1) {
      return { firstPart: text, secondPart: null };
    }

    const part1 = text.substring(0, separatorIndex).trim();
    const part2 = text.substring(separatorIndex + separator.length).trim();

    return { firstPart: part1, secondPart: part2 };
  }

  public static safeStringify(object: any): string {
    let result: string;
    try {
      result = JSON.stringify(object);
      return result;
    } catch (error) {
      // swallow error and proceed to sanitize the object
    }

    const simpleObject: any = {};

    Object.keys(object).forEach(prop => {
      if (object.hasOwnProperty(prop)) {
        if (typeof object[prop] !== 'object' && typeof object[prop] !== 'function') {
          simpleObject[prop] = object[prop];
        }
      }
    });

    result = "[***Sanitized Object***]: " + JSON.stringify(simpleObject);

    return result;
  }

  public static JSonTryParse(value: string): any {
    try {
      return JSON.parse(value);
    } catch (e) {
      return value === "undefined" ? void 0 : value;
    }
  }

  public static TestIsUndefined(value: any): boolean {
    return typeof value === 'undefined';
  }

  public static TestIsString(value: any): boolean {
    return typeof value === 'string' || value instanceof String;
  }

  public static capitalizeFirstLetter(text: string): string {
    return text ? text.charAt(0).toUpperCase() + text.slice(1) : text;
  }

  public static toTitleCase(text: string): string {
    return text.replace(/\w\S*/g, (subString) => {
      return subString.charAt(0).toUpperCase() + subString.substring(1).toLowerCase();
    });
  }

  public static toLowerCase(items: string): string;
  public static toLowerCase(items: string[]): string[];
  public static toLowerCase(items: any): string | string[] {
    if (Array.isArray(items)) {
      return items.map(item => item.toLowerCase());
    } else if (typeof items === 'string' || items instanceof String) {
      return items.toLowerCase();
    }
  }

  public static uniqueId(): string {
    return this.randomNumber(1000000, 9000000).toString();
  }

  public static randomNumber(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }

  public static baseUrl(): string {
    return window.location.origin ? window.location.origin :
      window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');
  }

  public static printDateOnly(date: Date): string {
    const newDate = new Date(date);
    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    const dayOfWeek = newDate.getDay();
    const dayOfMonth = newDate.getDate();
    let sup = "";
    const month = newDate.getMonth();
    const year = newDate.getFullYear();

    if (dayOfMonth === 1 || dayOfMonth === 21 || dayOfMonth === 31) {
      sup = "st";
    } else if (dayOfMonth === 2 || dayOfMonth === 22) {
      sup = "nd";
    } else if (dayOfMonth === 3 || dayOfMonth === 23) {
      sup = "rd";
    } else {
      sup = "th";
    }

    return `${dayNames[dayOfWeek]}, ${dayOfMonth}${sup} ${monthNames[month]} ${year}`;
  }

  public static printTimeOnly(date: Date): string {
    const newDate = new Date(date);
    let hour = newDate.getHours();
    let minute = newDate.getMinutes().toString();
    const period = hour < 12 ? "AM" : "PM";

    if (hour === 0) {
      hour = 12;
    } else if (hour > 12) {
      hour = hour - 12;
    }

    if (minute.length === 1) {
      minute = "0" + minute;
    }

    return `${hour}:${minute} ${period}`;
  }

  public static printDate(date: Date, separator = "at"): string {
    return `${Utilities.printDateOnly(date)} ${separator} ${Utilities.printTimeOnly(date)}`;
  }

  public static printFriendlyDate(date: Date, separator = "-"): string {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    const test = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    if (test.toDateString() === today.toDateString()) {
      return `Today ${separator} ${Utilities.printTimeOnly(date)}`;
    }
    if (test.toDateString() === yesterday.toDateString()) {
      return `Yesterday ${separator} ${Utilities.printTimeOnly(date)}`;
    }
    return Utilities.printDate(date, separator);
  }

  public static printShortDate(date: Date, separator = "/", dateTimeSeparator = "-"): string {
    let day = date.getDate().toString();
    let month = (date.getMonth() + 1).toString();
    const year = date.getFullYear();

    if (day.length === 1) {
      day = "0" + day;
    }
    if (month.length === 1) {
      month = "0" + month;
    }

    return `${month}${separator}${day}${separator}${year} ${dateTimeSeparator} ${Utilities.printTimeOnly(date)}`;
  }

  public static parseDate(date: any): Date {
    if (date) {
      if (date instanceof Date) {
        return date;
      }
      if (typeof date === 'string' || date instanceof String) {
        if (date.search(/[a-su-z+]/i) === -1) {
          date = date + "Z";
        }
        return new Date(date);
      }
      if (typeof date === 'number' || date instanceof Number) {
        return new Date(date);
      }
    }
    return null;
  }

  public static printDuration(start: Date, end: Date): string {
    const startDate = new Date(start);
    const endDate = new Date(end);
    let delta = Math.abs(startDate.getTime() - endDate.getTime()) / 1000;

    const days = Math.floor(delta / 86400);
    delta -= days * 86400;

    const hours = Math.floor(delta / 3600) % 24;
    delta -= hours * 3600;

    const minutes = Math.floor(delta / 60) % 60;
    delta -= minutes * 60;

    const seconds = Math.floor(delta % 60);

    let printedDays = "";

    if (days) {
      printedDays = `${days} days`;
    }
    if (hours) {
      printedDays += printedDays ? `, ${hours} hours` : `${hours} hours`;
    }
    if (minutes) {
      printedDays += printedDays ? `, ${minutes} minutes` : `${minutes} minutes`;
    }
    if (seconds) {
      printedDays += printedDays ? ` and ${seconds} seconds` : `${seconds} seconds`;
    }
    if (!printedDays) {
      printedDays = "0";
    }

    return printedDays;
  }

  public static getAge(birthDate: any, otherDate: any): number {
    const birth = new Date(birthDate);
    const other = new Date(otherDate);
    let years = other.getFullYear() - birth.getFullYear();

    if (other.getMonth() < birth.getMonth() ||
      (other.getMonth() === birth.getMonth() && other.getDate() < birth.getDate())) {
      years--;
    }

    return years;
  }

  public static searchArray(searchTerm: string, caseSensitive: boolean, ...values: any[]): boolean {
    if (!searchTerm) return true;

    const term = caseSensitive ? searchTerm : searchTerm.toLowerCase();

    for (const value of values) {
      if (value != null) {
        let strValue = value.toString();
        if (!caseSensitive) {
          strValue = strValue.toLowerCase();
        }
        if (strValue.indexOf(term) !== -1) {
          return true;
        }
      }
    }

    return false;
  }

  public static expandCamelCase(text: string): string {
    if (!text) return text;
    return text.replace(/([A-Z])/g, ' $1').replace(/^./, (str) => str.toUpperCase());
  }

  public static testIsAbsoluteUrl(url: string): boolean {
    const regex = new RegExp('^(?:[a-z]+:)?//', 'i');
    return regex.test(url);
  }

  public static convertToAbsoluteUrl(url: string): string {
    return Utilities.testIsAbsoluteUrl(url) ? url : '//' + url;
  }

  public static removeNulls(obj: any): any {
    const isArray = Array.isArray(obj);

    Object.keys(obj).forEach(k => {
      if (obj[k] === null) {
        if (isArray) {
          obj.splice(Number(k), 1);
        } else {
          delete obj[k];
        }
      } else if (typeof obj[k] === "object") {
        Utilities.removeNulls(obj[k]);
      }
      if (isArray && obj.length === Number(k)) {
        Utilities.removeNulls(obj);
      }
    });

    return obj;
  }

  public static debounce(func: (...args: any[]) => any, wait: number, immediate?: boolean): any {
    let timeout: any;
    return function (...args: any[]) {
      const context = this;
      const later = () => {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  }

  public static cookies = {
    getItem: (sKey: string) => {
      return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + 
        encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
    },
    setItem: (sKey: string, sValue: string, vEnd: number | string | Date, sPath?: string, sDomain?: string, bSecure?: boolean) => {
      if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
        return false;
      }
      let sExpires = "";
      if (vEnd) {
        switch (vEnd.constructor) {
          case Number:
            sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
            break;
          case String:
            sExpires = "; expires=" + vEnd;
            break;
          case Date:
            sExpires = "; expires=" + vEnd.toUTCString();
            break;
        }
      }
      document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + 
        sExpires + "; HttpOnly;secure" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
      return true;
    },
    removeItem: (sKey: string, sPath?: string, sDomain?: string) => {
      if (!sKey) {
        return false;
      }
      document.cookie = encodeURIComponent(sKey) + 
        "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + "; HttpOnly;secure" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
      return true;
    },
    hasItem: (sKey: string) => {
      return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
    },
    keys: () => {
      const aKeys = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, "").split(/\\s*(?:\\=[^;]*)?;\\s*/);
      return aKeys.map(key => decodeURIComponent(key));
    }
  }
}
```