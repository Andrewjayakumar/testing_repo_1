```
```typescript
import { Injectable } from '@angular/core';
import { HttpErrorResponse } from '@angular/common/http';

@Injectable({
  providedIn: 'root'
})
export class Utilities {

  public static readonly captionAndMessageSeparator = ":";
  public static readonly noNetworkMessageCaption = "No Network";
  public static readonly noNetworkMessageDetail = "The server cannot be reached";
  public static readonly accessDeniedMessageCaption = "Access Denied!";
  public static readonly accessDeniedMessageDetail = "";

  public static getHttpResponseMessage(data: HttpErrorResponse | any): string[] {
    const responses: string[] = [];

    if (data instanceof HttpErrorResponse) {
      if (this.checkNoNetwork(data)) {
        responses.push(`${this.noNetworkMessageCaption}${this.captionAndMessageSeparator} ${this.noNetworkMessageDetail}`);
      } else {
        try {
          const responseObject = data.error;
          if (typeof responseObject === 'object' && responseObject !== null) {
            for (const key in responseObject) {
              if (key) {
                responses.push(`${key}${this.captionAndMessageSeparator} ${responseObject[key]}`);
              } else if (responseObject[key]) {
                responses.push(responseObject[key].toString());
              }
            }
          }
        } catch (error) {
          // swallow error
        }
      }

      if (!responses.length && data.message) {
        responses.push(`${data.statusText}: ${data.message}`);
      }
    }

    if (!responses.length) {
      responses.push(data.toString());
    }

    if (this.checkAccessDenied(data)) {
      responses.splice(0, 0, `${this.accessDeniedMessageCaption}${this.captionAndMessageSeparator} ${this.accessDeniedMessageDetail}`);
    }

    return responses;
  }

  public static findHttpResponseMessage(messageToFind: string, data: HttpErrorResponse | any, seachInCaptionOnly = true, includeCaptionInResult = false): string {
    const searchString = messageToFind.toLowerCase();
    const httpMessages = this.getHttpResponseMessage(data);

    for (const message of httpMessages) {
      const fullMessage = Utilities.splitInTwo(message, this.captionAndMessageSeparator);
      if (fullMessage.firstPart && fullMessage.firstPart.toLowerCase().indexOf(searchString) !== -1) {
        return includeCaptionInResult ? message : (fullMessage.secondPart || fullMessage.firstPart);
      }
    }

    if (!seachInCaptionOnly) {
      for (const message of httpMessages) {
        if (message.toLowerCase().indexOf(searchString) !== -1) {
          if (includeCaptionInResult) {
            return message;
          } else {
            const fullMessage = Utilities.splitInTwo(message, this.captionAndMessageSeparator);
            return fullMessage.secondPart || fullMessage.firstPart;
          }
        }
      }
    }

    return null;
  }

  public static checkNoNetwork(response: any): boolean {
    return response && response.status === 0;
  }

  public static checkAccessDenied(response: any): boolean {
    return response && response.status === 403;
  }

  public static checkNotFound(response: any): boolean {
    return response && response.status === 404;
  }

  public static checkIsLocalHost(url: string, base?: string): boolean {
    if (url) {
      const location = new URL(url, base);
      return location.hostname === "localhost" || location.hostname === "127.0.0.1";
    }
    return false;
  }

  public static getQueryParamsFromString(paramString: string) {
    if (!paramString) {
      return null;
    }
    const params: { [key: string]: string } = {};
    for (const param of paramString.split("&")) {
      const keyValue = Utilities.splitInTwo(param, "=");
      params[keyValue.firstPart] = keyValue.secondPart;
    }
    return params;
  }

  public static splitInTwo(text: string, separator: string): { firstPart: string, secondPart: string } {
    const separatorIndex = text.indexOf(separator);
    if (separatorIndex === -1) {
      return { firstPart: text, secondPart: null };
    }
    const part1 = text.substring(0, separatorIndex).trim();
    const part2 = text.substring(separatorIndex + separator.length).trim();
    return { firstPart: part1, secondPart: part2 };
  }

  public static safeStringify(object: any): string {
    let result: string;
    try {
      result = JSON.stringify(object);
      return result;
    } catch (error) {
      // continue to sanitize object
    }
    const simpleObject: any = {};
    for (const prop in object) {
      if (!object.hasOwnProperty(prop)) {
        continue;
      }
      if (typeof object[prop] === 'object') {
        continue;
      }
      if (typeof object[prop] === 'function') {
        continue;
      }
      simpleObject[prop] = object[prop];
    }
    result = "[***Sanitized Object***]: " + JSON.stringify(simpleObject);
    return result;
  }

  public static JSonTryParse(value: string) {
    try {
      return JSON.parse(value);
    } catch (e) {
      if (value === "undefined") {
        return void 0;
      }
      return value;
    }
  }

  public static TestIsUndefined(value: any): boolean {
    return typeof value === 'undefined';
  }

  public static TestIsString(value: any): boolean {
    return typeof value === 'string' || value instanceof String;
  }

  public static capitalizeFirstLetter(text: string): string {
    if (text) {
      return text.charAt(0).toUpperCase() + text.slice(1);
    } else {
      return text;
    }
  }

  public static toTitleCase(text: string): string {
    return text.replace(/\w\S*/g, (subString) => {
      return subString.charAt(0).toUpperCase() + subString.substring(1).toLowerCase();
    });
  }

  public static toLowerCase(items: string): string;
  public static toLowerCase(items: string[]): string[];
  public static toLowerCase(items: any): string | string[] {
    if (items instanceof Array) {
      const loweredRoles: string[] = [];
      for (let i = 0; i < items.length; i++) {
        loweredRoles[i] = items[i].toLowerCase();
      }
      return loweredRoles;
    } else if (typeof items === 'string' || items instanceof String) {
      return items.toLowerCase();
    }
  }

  public static uniqueId(): string {
    return this.randomNumber(1000000, 9000000).toString();
  }

  public static randomNumber(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }

  public static baseUrl(): string {
    if (window.location.origin) {
      return window.location.origin;
    }
    return window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');
  }

  public static printDateOnly(date: Date): string {
    date = new Date(date);
    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const dayOfWeek = date.getDay();
    const dayOfMonth = date.getDate();
    let sup = "";
    const month = date.getMonth();
    const year = date.getFullYear();

    if (dayOfMonth === 1 || dayOfMonth === 21 || dayOfMonth === 31) {
      sup = "st";
    } else if (dayOfMonth === 2 || dayOfMonth === 22) {
      sup = "nd";
    } else if (dayOfMonth === 3 || dayOfMonth === 23) {
      sup = "rd";
    } else {
      sup = "th";
    }

    const dateString = `${dayNames[dayOfWeek]}, ${dayOfMonth}${sup} ${monthNames[month]} ${year}`;
    return dateString;
  }

  public static printTimeOnly(date: Date): string {
    date = new Date(date);
    let minute = date.getMinutes().toString();
    let hour = date.getHours();
    const period = hour < 12 ? "AM" : "PM";

    if (hour === 0) {
      hour = 12;
    }
    if (hour > 12) {
      hour = hour - 12;
    }

    if (minute.length === 1) {
      minute = "0" + minute;
    }

    const timeString = `${hour}:${minute} ${period}`;
    return timeString;
  }

  public static printDate(date: Date, separator = "at"): string {
    return `${Utilities.printDateOnly(date)} ${separator} ${Utilities.printTimeOnly(date)}`;
  }

  public static printFriendlyDate(date: Date, separator = "-"): string {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    const test = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    if (test.toDateString() === today.toDateString()) {
      return `Today ${separator} ${Utilities.printTimeOnly(date)}`;
    }
    if (test.toDateString() === yesterday.toDateString()) {
      return `Yesterday ${separator} ${Utilities.printTimeOnly(date)}`;
    } else {
      return Utilities.printDate(date, separator);
    }
  }

  public static printShortDate(date: Date, separator = "/", dateTimeSeparator = "-"): string {
    let day = date.getDate().toString();
    let month = (date.getMonth() + 1).toString();
    const year = date.getFullYear();

    if (day.length === 1) {
      day = "0" + day;
    }
    if (month.length === 1) {
      month = "0" + month;
    }

    return `${month}${separator}${day}${separator}${year} ${dateTimeSeparator} ${Utilities.printTimeOnly(date)}`;
  }

  public static parseDate(date: any): Date {
    if (date) {
      if (date instanceof Date) {
        return date;
      }
      if (typeof date === 'string' || date instanceof String) {
        if (date.search(/[a-su-z+]/i) === -1) {
          date = date + "Z";
        }
        return new Date(date);
      }
      if (typeof date === 'number' || date instanceof Number) {
        return new Date(date);
      }
    }
  }

  public static printDuration(start: Date, end: Date): string {
    start = new Date(start);
    end = new Date(end);
    let delta = Math.abs(start.valueOf() - end.valueOf()) / 1000;
    const days = Math.floor(delta / 86400);
    delta -= days * 86400;
    const hours = Math.floor(delta / 3600) % 24;
    delta -= hours * 3600;
    const minutes = Math.floor(delta / 60) % 60;
    delta -= minutes * 60;
    const seconds = delta % 60;
    let printedDays = "";

    if (days) {
      printedDays = `${days} days`;
    }
    if (hours) {
      printedDays += printedDays ? `, ${hours} hours` : `${hours} hours`;
    }
    if (minutes) {
      printedDays += printedDays ? `, ${minutes} minutes` : `${minutes} minutes`;
    }
    if (seconds) {
      printedDays += printedDays ? ` and ${seconds} seconds` : `${seconds} seconds`;
    }
    if (!printedDays) {
      printedDays = "0";
    }
    return printedDays;
  }

  public static getAge(birthDate: any, otherDate: any): number {
    birthDate = new Date(birthDate);
    otherDate = new Date(otherDate);
    let years = otherDate.getFullYear() - birthDate.getFullYear();
    if (
      otherDate.getMonth() < birthDate.getMonth() ||
      (otherDate.getMonth() === birthDate.getMonth() && otherDate.getDate() < birthDate.getDate())
    ) {
      years--;
    }
    return years;
  }

  public static searchArray(searchTerm: string, caseSensitive: boolean, ...values: any[]): boolean {
    if (!searchTerm) return true;
    if (!caseSensitive) {
      searchTerm = searchTerm.toLowerCase();
    }
    for (const value of values) {
      if (value != null) {
        let strValue = value.toString();
        if (!caseSensitive) {
          strValue = strValue.toLowerCase();
        }
        if (strValue.indexOf(searchTerm) !== -1) {
          return true;
        }
      }
    }
    return false;
  }

  public static expandCamelCase(text: string): string {
    if (!text) return text;
    return text.replace(/([A-Z])/g, ' $1').replace(/^./, (str) => {
      return str.toUpperCase();
    });
  }

  public static testIsAbsoluteUrl(url: string): boolean {
    const r = new RegExp('^(?:[a-z]+:)?//', 'i');
    return r.test(url);
  }

  public static convertToAbsoluteUrl(url: string): string {
    return Utilities.testIsAbsoluteUrl(url) ? url : '//' + url;
  }

  public static removeNulls(obj: any): any {
    const isArray = obj instanceof Array;
    for (const k in obj) {
      if (obj[k] === null) {
        isArray ? obj.splice(+k, 1) : delete obj[k];
      } else if (typeof obj[k] === "object") {
        Utilities.removeNulls(obj[k]);
      }
      if (isArray && obj.length === +k) {
        Utilities.removeNulls(obj);
      }
    }
    return obj;
  }

  public static debounce(func: (...args: any[]) => any, wait: number, immediate?: boolean): (...args: any[]) => any {
    let timeout: any;
    return function (...args: any[]) {
      const context = this;
      const later = function () {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  }

  public static cookies = {
    getItem: (sKey: string) => {
      return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
    },
    setItem: (sKey: string, sValue: string, vEnd?: any, sPath?: string, sDomain?: string, bSecure?: boolean) => {
      if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
        return false;
      }
      let sExpires = "";
      if (vEnd) {
        switch (vEnd.constructor) {
          case Number:
            sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
            break;
          case String:
            sExpires = "; expires=" + vEnd;
            break;
          case Date:
            sExpires = "; expires=" + vEnd.toUTCString();
            break;
        }
      }
      document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + "; HttpOnly;secure" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
      return true;
    },
    removeItem: (sKey: string, sPath?: string, sDomain?: string) => {
      if (!sKey) {
        return false;
      }
      document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + "; HttpOnly;secure" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
      return true;
    },
    hasItem: (sKey: string) => {
      return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
    },
    keys: () => {
      const aKeys = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, "").split(/\\s*(?:\\=[^;]*)?;\\s*/);
      for (let nIdx = 0; nIdx < aKeys.length; nIdx++) {
        aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
      }
      return aKeys;
    }
  }
}
```
```